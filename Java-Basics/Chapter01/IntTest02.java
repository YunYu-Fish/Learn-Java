/*
  - 大容量不能直接赋值给小容量，而是要增加强制类型转换符

  - java中有一个语法规则：
    当整数型字面量没有超出给byte当取值范围，这个整数型字面值可以直接赋值给byte
    ！！：同理short char也是
*/

public class IntTest02{

  public static void main(String[] args){

    //不存在类型转换
    long x = 100L;
    System.out.println(x);

    //x是long类型，占用8个字节，而y变量是int类型，占用4个字节
    //会出现编译报错，错误显示：不兼容的类型，从long转换到int可能会有损失
    //int y = x;

    //大容量转换成小容量，必须加强制类型转换符
    //底层是怎么进行强制类型转换的呢？
    //long类型100l的二进制是：00000000 00000000 00000000 00000000 00000000 00000000 00000000 01100100
    //强转为int类型 会自动将“前面”的4个字节砍掉变为：00000000 00000000 00000000 01100100
    int y = (int)x;//这个(int)就是强制类型转换符，但是可能会损失精度【取决于数据】

    //300int类型对应的二进制是：00000000 00000000 00000001 00101100
    //强转之后变为00101100也就是44
    byte a = (byte)300;
    System.out.println(a);

    //按理应该报错，但是编译通过，无需强转
    byte b = 1;
    byte c = 127;
    //下面编译报错，因为128超出了byte的取值范围,需要强转
    //byte d = 128;

  }
}
